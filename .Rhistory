simple_distance<-function(lon1,lat1,lon2,lat2){
elements<-length(lon1)
distances<-geosphere::distHaversine(cbind(lon1, lat1), cbind(lon2, lat2))
return(distances)}
fishing_grounds<- function(df, depthraster){
depth<- as.data.frame(rasterToPoints(depthraster)) %>%
dplyr::rename(depth=gebco) %>%
## notice that depth is -99999 for land, we need to change that
mutate(depth=ifelse(depth==-99999,10000,depth))
# turn it spatial
coordinates(depth)<-c("x","y")
# at start they are just long-lat observations
proj4string(depth) <-CRS("+proj=longlat +datum=WGS84")
# now we need to interpolate (this finds depth at each ping)
#this takes quite a long time!
interpolated_depths<-akima::interpp(x=coordinates(depth)[,1],
y=coordinates(depth)[,2],
z = depth$depth,
xo = df$longitude,
yo = df$latitude,
duplicate="strip"
)
#add to data frame
df$depth <- interpolated_depths$z
#change date time format
df$datetime<-ymd(df$date_time)
#remove uneccessary columns
df <- df %>% dplyr::select(-oid, -oid.1, -tracker_name, -unix_time, -battery_state, -date_time, -tracker_id.1, -tracker_status)
### replace -99999 for lat and long with missing values
df <-
df %>%
dplyr::rename(boatname = boat_name) %>%
dplyr::filter(longitude !=-99999) %>%
dplyr::filter(latitude !=-99999) %>%
dplyr::arrange(boatname,datetime)
df <-
df%>%
ungroup() %>%
#group by boat name, this makes sure that we compute difftime only when it's between the same boat
dplyr::group_by(boatname) %>%
dplyr::mutate(time_diff=difftime(`datetime`,
lag(`datetime`,order_by=`datetime`),
unit="hours"))
# ### this is the burst as defined by the original script, we use it only briefly
df <-
df %>%
ungroup() %>%
#begin of burst is flagged here as either a completely new boat or a week has passed
mutate(BeginOfBurst = ifelse(is.na(time_diff) | time_diff > 7*24*60*60 ,1,0))  %>%
mutate(burst = cumsum(BeginOfBurst)) %>%
dplyr::select(-BeginOfBurst)
df<-
df %>% ungroup() %>%
group_by(burst) %>%
distinct(`datetime`,.keep_all = TRUE) %>%
ungroup()
## let's try to build distances by hand without using new libraries
df<-
df %>%
group_by(burst) %>%
# compute distance
mutate(distance = simple_distance(longitude,latitude,lag(longitude),lag(latitude))) %>%
# distance in terms of km!
mutate(distance= distance/1000)
#now let's compute speed in km/h
df<-
df %>%
mutate(speed = distance/as.numeric(time_diff))
#tag bad observations:
df<-
df %>%
group_by(burst) %>%
mutate(quality = ifelse(
(speed < 30 | is.na(speed)) & (lag(speed)<30 | is.na(lag(speed))),1,0))
## simply drop all observations without lat and long
df<-
df %>%
filter(!is.na(longitude)) %>%
filter(!is.na(latitude))
#Find other bathymetry properties based on the depthraster
slope <- terrain(depthraster, opt='slope', unit='degrees')
aspect <- terrain(depthraster, opt='aspect', unit='degrees')
BRI <- terrain(depthraster, opt='TRI', unit='degrees')
BPI <- terrain(depthraster, opt='TPI', unit='degrees')
roughness <- terrain(depthraster, opt='roughness', unit='degrees')
#Change all this to dataframe
slope <- as.data.frame(rasterToPoints(slope))
aspect <- as.data.frame(rasterToPoints(aspect))
BRI <- as.data.frame(rasterToPoints(BRI))
BPI <- as.data.frame(rasterToPoints(BPI))
roughness <- as.data.frame(rasterToPoints(roughness))
#Interpolate slope
interpolated_slopes <- akima::interpp(x=coordinates(slope)[,1],
y=coordinates(slope)[,2],
z = slope$slope,
xo = df$longitude,
yo = df$latitude,
duplicate="strip"
)
#Interpolated aspect
interpolated_aspect <- akima::interpp(x=coordinates(aspect)[,1],
y=coordinates(aspect)[,2],
z = aspect$aspect,
xo = df$longitude,
yo = df$latitude,
duplicate="strip"
)
#Interpolated BRI
interpolated_BRI <- akima::interpp(x=coordinates(BRI)[,1],
y=coordinates(BRI)[,2],
z = BRI$tri,
xo = df$longitude,
yo = df$latitude,
duplicate="strip"
)
#Interpolated BPI
interpolated_BPI <- akima::interpp(x=coordinates(BPI)[,1],
y=coordinates(BPI)[,2],
z = BPI$tpi,
xo = df$longitude,
yo = df$latitude,
duplicate="strip"
)
#Interpolate roughness
interpolated_roughness <- akima::interpp(x=coordinates(roughness)[,1],
y=coordinates(roughness)[,2],
z = roughness$roughness,
xo = df$longitude,
yo = df$latitude,
duplicate="strip"
)
#add that to the original data frame
df$Aspect= interpolated_aspect$z
df$Slope =interpolated_slopes$z
df$BRI= interpolated_BRI$z
df$BPI=interpolated_BPI$z
df$Roughness=interpolated_roughness$z
return(df)}
setwd(ifis)
setwd('./ifish')
document()
document()
setwd('./ifish')
document()
# Export all names
exportPattern(".")
devtools::load_all(".")
document()
setwd('./ifish')
document()
devtools::load_all(".")
library(ifish)
devtools::document()
devtools::load_all()
m <- dbDriver("PostgreSQL")
con <- dbConnect(m,host='localhost', port='5432',user="postgres", password="fishy", dbname="ifish_05142019")
#con <- dbConnect(m,host='localhost', port='5432',user="postgres", password="fishy", dbname="ifish_01242020")
rs <- dbSendQuery(con, "SELECT b.boat_name, b.program_type, b.registration_port, b.fishing_gear, b.gt_estimate, b.oid,
t.boat_id, t.tracker_id,t.tracker_status, t.tracker_start_date, t.tracker_end_date, s.*
FROM ifish_boat b
INNER JOIN ifish_boat_tracker t on b.oid= t.boat_id
INNER JOIN ifish_findmespot s on t.tracker_id=s.tracker_id
WHERE t.tracker_status=1 and s.date_time >= t.tracker_start_date
UNION
SELECT b.boat_name, b.program_type, b.registration_port, b.fishing_gear, b.gt_estimate, b.oid,
t.boat_id, t.tracker_id, t.tracker_status, t.tracker_start_date, t.tracker_end_date, s.*
FROM ifish_boat b
INNER JOIN ifish_boat_tracker t on b.oid= t.boat_id
INNER JOIN ifish_findmespot s on t.tracker_id=s.tracker_id
WHERE t.tracker_status=0 and s.date_time >= t.tracker_start_date and
s.date_time <= t.tracker_end_date;")
df2 <- fetch(rs, n=-1)
library(foreign)
library(reshape2)
library(gdata) # requires Perl
library(ggplot2)
library(tidyr)
library(dplyr)
library(knitr)
library(xtable)
library(RPostgreSQL)
library(R2HTML)
library(memisc)
library(gmodels)
library(RcppEigen)
library(lme4)
library(bootstrap)
library(fishmethods)
library(stargazer)
library(mosaic)
library(doBy)
library(ncdf4)
library(raster)
library(ggmap)
library(rgdal)
library(rgeos)
library(maptools)
library(sf)
m <- dbDriver("PostgreSQL")
con <- dbConnect(m,host='localhost', port='5432',user="postgres", password="fishy", dbname="ifish_05142019")
#con <- dbConnect(m,host='localhost', port='5432',user="postgres", password="fishy", dbname="ifish_01242020")
rs <- dbSendQuery(con, "SELECT b.boat_name, b.program_type, b.registration_port, b.fishing_gear, b.gt_estimate, b.oid,
t.boat_id, t.tracker_id,t.tracker_status, t.tracker_start_date, t.tracker_end_date, s.*
FROM ifish_boat b
INNER JOIN ifish_boat_tracker t on b.oid= t.boat_id
INNER JOIN ifish_findmespot s on t.tracker_id=s.tracker_id
WHERE t.tracker_status=1 and s.date_time >= t.tracker_start_date
UNION
SELECT b.boat_name, b.program_type, b.registration_port, b.fishing_gear, b.gt_estimate, b.oid,
t.boat_id, t.tracker_id, t.tracker_status, t.tracker_start_date, t.tracker_end_date, s.*
FROM ifish_boat b
INNER JOIN ifish_boat_tracker t on b.oid= t.boat_id
INNER JOIN ifish_findmespot s on t.tracker_id=s.tracker_id
WHERE t.tracker_status=0 and s.date_time >= t.tracker_start_date and
s.date_time <= t.tracker_end_date;")
df2 <- fetch(rs, n=-1)
dbHasCompleted(rs)
#load some depth information
library(raster)
depth <- raster("/Users/ElleWibisono/Desktop/Dissertation/R codes/gebco.tif")
ifish::fishing_grounds(df2, depth)
devtools::load_all(".")
ifish::fishing_grounds(df2, depth)
devtools::load_all(".")
ifish::fishing_grounds(df2, depth)
devtools::load_all(".")
ifish::fishing_grounds(df2, depth)
?rbind
###==========================================
#Community data with the top 5 species in each gear type
#Not use top 20 species overall because we are NOT assuming that
#they all belong to one fishery/ metier
TopSpp <- df2 %>%
split(.$fishing_gear) %>%
purrr::map(group_by,fishname) %>%
purrr::map(dplyr::summarise,count=n()) %>%
purrr::map(dplyr::arrange,desc(count)) %>%
purrr::map(dplyr::top_n,nSpecies)
df2 %>%
split(.$fishing_gear) %>%
purrr::map(group_by,fishname) %>%
purrr::map(dplyr::summarise,count=n()) %>%
purrr::map(dplyr::arrange,desc(count))
df2 %>%
split(.$fishing_gear) %>%
purrr::map(dplyr::group_by,fishname) %>%
purrr::map(dplyr::summarise,count=n()) %>%
purrr::map(dplyr::arrange,desc(count))
#con <- dbConnect(m,host='localhost', port='5432',user="postgres", password="fishy", dbname="ifish_01242020")
rs <- dbSendQuery(con, "SELECT b.boat_name, b.program_type, b.registration_port, b.fishing_gear, b.gt_estimate, b.oid,
t.boat_id, t.tracker_id,t.tracker_status, t.tracker_start_date, t.tracker_end_date, s.*
FROM ifish_boat b
INNER JOIN ifish_boat_tracker t on b.oid= t.boat_id
INNER JOIN ifish_findmespot s on t.tracker_id=s.tracker_id
WHERE t.tracker_status=1 and s.date_time >= t.tracker_start_date
UNION
SELECT b.boat_name, b.program_type, b.registration_port, b.fishing_gear, b.gt_estimate, b.oid,
t.boat_id, t.tracker_id, t.tracker_status, t.tracker_start_date, t.tracker_end_date, s.*
FROM ifish_boat b
INNER JOIN ifish_boat_tracker t on b.oid= t.boat_id
INNER JOIN ifish_findmespot s on t.tracker_id=s.tracker_id
WHERE t.tracker_status=0 and s.date_time >= t.tracker_start_date and
s.date_time <= t.tracker_end_date;")
dftracker <- fetch(rs, n=-1)
dbHasCompleted(rs)
rs2 <- dbSendQuery(con, "SELECT f.oid, f.var_a, f.var_b, f.fish_genus, f.fish_species, f.lmat, f.lopt, f.linf, f.lmax,s.cm,
d.boat_id, d.landing_date, d.wpp1, d.wpp2, d.wpp3, s.landing_id, b.oid, b.boat_name, b.boat_code,
b.program_site, b.gt_estimate, b.gt_declared, b.size_category, b.fishing_gear, b.program_type
FROM ifish_fish f
INNER JOIN ifish_sizing s on f.oid= s.fish_id
INNER JOIN ifish_deepslope d on s.landing_id = d.oid
INNER JOIN ifish_boat b on d.boat_id= b.oid
WHERE s.fish_id > 0 and s.data_quality = 1
ORDER BY s.landing_id")
dffish <- fetch(rs2, n=-1)
rs2 <-dbSendQuery(con, "SELECT f.oid, f.var_a, f.var_b, f.fish_genus, f.fish_species, f.lmat, f.lopt, f.linf, f.lmax, s.cm,
d.boat_id, d.landing_date, d.wpp1, d.wpp2, d.wpp3, d.first_codrs_picture_date, s.landing_id,
b.oid, b.registration_port,
b.gt_estimate, b.gt_declared, b.program_type, b.fishing_gear, b. boat_name
FROM ifish_fish f
INNER JOIN ifish_sizing s on f.oid= s.fish_id
INNER JOIN ifish_deepslope d on s.landing_id = d.oid
INNER JOIN ifish_boat b on d.boat_id= b.oid
WHERE s.fish_id > 0 and s.data_quality = 1
ORDER BY s.landing_id")
dffish <- fetch(rs2, n=-1)
fishing_locations <- fishing_grounds(df=dftracker, depthraster = depthraster)
depthraster <- raster("/Users/ElleWibisono/Desktop/Dissertation/R codes/gebco.tif")
fishing_locations <- fishing_grounds(df=dftracker, depthraster = depthraster)
devtools::load_all(".")
fishing_locations <- fishing_grounds(df=dftracker, depthraster = depthraster)
library(lubridate)
####Load fishing locations
fishing_locations <- fishing_grounds(df=dftracker, depthraster = depthraster)
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
View(dftracker)
####Load fishing locations
fishing_locations <- fishing_grounds(df=dftracker, depthraster = depthraster)
#filter for snapper only
dffish <- dffish %>%setNames(make.unique(names(.))) %>%
dplyr::filter(program_type=='Snapper') %>%
unite(fishname, fish_genus, fish_species, sep=" ", remove= FALSE) %>%
dplyr::mutate(weight=(var_a *(cm^var_b)/1000))
#Remove data with no fishname
df2 <- dffish[!(is.na(dffish$fishname) | dffish$fishname==" "), ] #remove NAs and blank fishnames
####Load fishing locations
fishing_locations <- fishing_grounds(df=dftracker, depthraster = depthraster)
dftracker <- dftracker %>%setNames(make.unique(names(.)))
####Load fishing locations
fishing_locations <- fishing_grounds(df=dftracker, depthraster = depthraster)
fishinglocations$datetime <- as.Date(fishinglocations$datetime)
fishinglocations$datetime <- as.Date(fishing_locations$datetime)
####Load fishing locations
fishinglocations <- fishing_grounds(df=dftracker, depthraster = depthraster)
fishinglocations$datetime <- as.Date(fishinglocations$datetime)
#df containing all the environmental predictors for the top species
mergedlandings <- merge(x=dffish, y=fishinglocations, by.x=c('first_codrs_picture_date','boat_name'), by.y=c('datetime','boatname'), all=FALSE)
View(dffish)
View(dftracker)
dffish$first_codrs_picture_date
con <- dbConnect(m,host='localhost', port='5432',user="postgres", password="fishy", dbname="ifish_01242020")
#con <- dbConnect(m,host='localhost', port='5432',user="postgres", password="fishy", dbname="ifish_01242020")
rs <- dbSendQuery(con, "SELECT b.boat_name, b.program_type, b.registration_port, b.fishing_gear, b.gt_estimate, b.oid,
t.boat_id, t.tracker_id,t.tracker_status, t.tracker_start_date, t.tracker_end_date, s.*
FROM ifish_boat b
INNER JOIN ifish_boat_tracker t on b.oid= t.boat_id
INNER JOIN ifish_findmespot s on t.tracker_id=s.tracker_id
WHERE t.tracker_status=1 and s.date_time >= t.tracker_start_date
UNION
SELECT b.boat_name, b.program_type, b.registration_port, b.fishing_gear, b.gt_estimate, b.oid,
t.boat_id, t.tracker_id, t.tracker_status, t.tracker_start_date, t.tracker_end_date, s.*
FROM ifish_boat b
INNER JOIN ifish_boat_tracker t on b.oid= t.boat_id
INNER JOIN ifish_findmespot s on t.tracker_id=s.tracker_id
WHERE t.tracker_status=0 and s.date_time >= t.tracker_start_date and
s.date_time <= t.tracker_end_date;")
dftracker <- fetch(rs, n=-1)
dbHasCompleted(rs)
rs2 <-dbSendQuery(con, "SELECT f.oid, f.var_a, f.var_b, f.fish_genus, f.fish_species, f.lmat, f.lopt, f.linf, f.lmax, s.cm,
d.boat_id, d.landing_date, d.wpp1, d.wpp2, d.wpp3, d.first_codrs_picture_date, s.landing_id,
b.oid, b.registration_port,
b.gt_estimate, b.gt_declared, b.program_type, b.fishing_gear, b. boat_name
FROM ifish_fish f
INNER JOIN ifish_sizing s on f.oid= s.fish_id
INNER JOIN ifish_deepslope d on s.landing_id = d.oid
INNER JOIN ifish_boat b on d.boat_id= b.oid
WHERE s.fish_id > 0 and s.data_quality = 1
ORDER BY s.landing_id")
dffish <- fetch(rs2, n=-1)
#load some depth information
library(raster)
#filter for snapper only
dffish <- dffish %>%setNames(make.unique(names(.))) %>%
dplyr::filter(program_type=='Snapper') %>%
unite(fishname, fish_genus, fish_species, sep=" ", remove= FALSE) %>%
dplyr::mutate(weight=(var_a *(cm^var_b)/1000))
#Remove data with no fishname
dffish <- dffish[!(is.na(dffish$fishname) | dffish$fishname==" "), ] #remove NAs and blank fishnames
dftracker <- dftracker %>%setNames(make.unique(names(.)))
View(dffish)
fishinglocations$datetime <- as.Date(fishinglocations$datetime)
#df containing all the environmental predictors for the top species
mergedlandings <- merge(x=dffish, y=fishinglocations, by.x=c('first_codrs_picture_date','boat_name'), by.y=c('datetime','boatname'), all=FALSE)
mergedlandings <- mergedlandings %>% dplyr::select(landing_id,fishing_gear.x, latitude, longitude, depth,
gt_estimate.x, first_codrs_picture_date, Aspect, Slope, BPI, BRI, Roughness) %>%
dplyr::distinct(landing_id, .keep_all=TRUE)
#But not all landings have matching envrionmental variables
#Total landings=4613
#Landing with matching spot trace pings=4435
#unmatched= 1964
###
#For the remainging landing_id, use average location and depth based on each boat_name
#find landing_id that has not been matched and extract that from the df2top data frame
matchedlandingid <- mergedlandings %>% distinct(landing_id)
#Filter df2top
unmatchedlandings <- anti_join(df2top, matchedlandingid) %>% distinct(landing_id, .keep_all=TRUE)
#Get boat names
unmatchedboat <- unmatchedlandings %>% distinct(boat_name)
#Filter out boats that have matched landings
fishinglocationsunmatched <- semi_join(fishinglocations, unmatchedboat, by=c('boatname'='boat_name'))
#Filter df2top
unmatchedlandings <- anti_join(dffish, matchedlandingid) %>% distinct(landing_id, .keep_all=TRUE)
#Get boat names
unmatchedboat <- unmatchedlandings %>% distinct(boat_name)
#Filter out boats that have matched landings
fishinglocationsunmatched <- semi_join(fishinglocations, unmatchedboat, by=c('boatname'='boat_name'))
#Calculate average lat, long, and depth by boat
meanstats <- fishinglocationsunmatched %>% group_by(boatname) %>%
mutate(meanlat=mean(latitude), meanlong=mean(longitude), meandepth=mean(depth), meanasp=mean(Aspect), meanslope=mean(Slope), meanBPI=mean(BPI),
meanBRI=mean(BRI), meanrough=mean(Roughness)) %>%
dplyr::select(boatname, meanlat, meanlong, meandepth, gt_estimate, fishing_gear, datetime, meanasp, meanslope, meanBPI, meanBRI, meanrough) %>%
distinct(boatname, .keep_all=TRUE)
#Add mean stats to the unmatchedlanding data frame #####
unmatchedlandings$boat_name <- as.factor(unmatchedlandings$boat_name)
unmatchedstats <-left_join(x=unmatchedlandings, y=meanstats, by=c('boat_name'='boatname'))
unmatchedstats <- unmatchedstats%>%
dplyr::select(landing_id, fishing_gear.x, gt_estimate.x, meanlat, meanlong, meandepth,datetime,meanasp, meanslope, meanBPI, meanBRI, meanrough)
na_boats <- unmatchedstats %>% filter_all(any_vars(is.na(.))) %>% #filter for any rows WITH NAs
dplyr::select(landing_id) #this is landing_id that has no fishing info
checkboatname <- semi_join(dffish, na_boats) %>% distinct(boat_name, registration_port, gt_estimate)
#These boats do not have corresponding fishing locations, so removed from community data and environmental data
#Remove NAs from environmental
unmatchedstats <- na.omit(unmatchedstats)
View(unmatchedstats)
View(mergedlandings)
#Create column order so we can reorder the column names so that the two dataframes will match
col_order <- c('landing_id','fishing_gear.x','meanlat','meanlong','meandepth','gt_estimate.x','datetime','meansp','meanslope','meanBPI','meanBRI','meanrough' )
#reorder by column index so that the two dataframes will match
unmatchedstats <- unmatchedstats[,col_order]
#Create column order so we can reorder the column names so that the two dataframes will match
col_order <- c('landing_id','fishing_gear.x','meanlat','meanlong','meandepth','gt_estimate.x','datetime','meansp','meanslope','meanBPI','meanBRI','meanrough' )
#reorder by column index so that the two dataframes will match
unmatchedstats <- unmatchedstats[,col_order]
#reorder by column index so that the two dataframes will match
unmatchedstats <- unmatchedstats[, col_order]
#reorder by column index so that the two dataframes will match
unmatchedstats <- unmatchedstats[col_order]
View(unmatchedstats)
str(unmatchedstats)
#Create column order so we can reorder the column names so that the two dataframes will match
col_order <- c('landing_id','fishing_gear.x','meanlat','meanlong','meandepth','gt_estimate.x','datetime','meanasp','meanslope','meanBPI','meanBRI','meanrough' )
#reorder by column index so that the two dataframes will match
unmatchedstats <- unmatchedstats[col_order]
View(unmatchedstats)
?stop
#ensure that the number of columns in col_order are the same as the number of columns in the data frame
if(length(col_order) != length(colnames(mergedlandings))){
stop('matched and unmatched data frame are different lengths, check columns')
}
#Combine mergedlandings data with unmacthedstats data
#Just stack em on top of each other essentially
colnames(unmatchedstats) <- colnames(mergedlandings)
environmental <- rbind(mergedlandings, unmatchedstats)
environmental <- rbind(mergedlandings, unmatchedstats)
environmental <- rbind(mergedlandings, unmatchedstats)
View(environmental)
View(na_boats)
unmatchedstats <-left_join(x=unmatchedlandings, y=meanstats, by=c('boat_name'='boatname'))
unmatchedstats <- unmatchedstats%>%
dplyr::select(landing_id, fishing_gear.x, gt_estimate.x, meanlat, meanlong, meandepth,datetime,meanasp, meanslope, meanBPI, meanBRI, meanrough)
View(unmatchedstats)
View(meanstats)
unmatchedstats <- unmatchedstats%>%
dplyr::select(landing_id, fishing_gear.x, gt_estimate.x, meanlat, meanlong, meandepth,datetime,meanasp, meanslope, meanBPI, meanBRI, meanrough)
na_boats <- unmatchedstats %>% filter_all(any_vars(is.na(.))) %>% #filter for any rows WITH NAs
dplyr::select(landing_id) #this is landing_id that has no fishing info
checkboatname <- semi_join(dffish, na_boats) %>% distinct(boat_name, registration_port, gt_estimate)
#These boats do not have corresponding fishing locations, so removed from community data and environmental data
#Remove NAs from environmental
unmatchedstats <- na.omit(unmatchedstats)
View(checkboatname)
#reorder by column index so that the two dataframes will match
unmatchedstats <- unmatchedstats[col_order]
#Combine mergedlandings data with unmacthedstats data
#Just stack em on top of each other essentially
colnames(unmatchedstats) <- colnames(mergedlandings)
environmental <- rbind(mergedlandings, unmatchedstats)
environmental$fishing_gear.x <- as.factor(environmental$fishing_gear.x)
View(dffish)
devtools::load_all(".")
devtools::load_all(".")
install_github("ellewibisono/ifish-data-processing")
devtools::install_github()
devtools::install_github("ellewibisono/ifish-data-processing")
devtools::install_github("ellewibisono/ifish-data-processing")
setwd("~/ifish")
install_github('ellewibisono/ifish-data-processing')
devtools::install_github("ellewibisono/ifish-data-processing")
